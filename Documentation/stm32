***주의***   

 - 레지스터 값을 변경하기 앞서 해당 인터페이스의 클럭을 활성화시켜야 한다. 비활성인 인터페이스의 레지스터 값 변경은 유효하지 않다.  
 - 일부 레지스터는 특정 단위로만(byte 또는 half-word, 또는 word) 접근할 수 있다(매뉴얼 참조). 일반화를 위해서는 워드단위로 접근할 것.  
 - 인터럽트를 얘기할 때 "외부"라는 접두사는 코어 밖에 내장된 EXTI 컨트롤러를 뜻한다.  

## 시스템 초기화

```
BOOT1 | BOOT0 | Boot Mode
------|-------|-------------------
 x       0       Main Flash memory
 0       1       System memory
 1       1       Embedded SRAM
```

리셋후 SYSCLK의 4번째 라이징 엣지에 위 핀들을 스캔. 스탠바이 모드에서 탈출할 때도 위 핀들을 스캔한다.

CPU는 부트모드를 결정한 후 주소 0x0000 0000에서 스택 포인터 주소를 로드하고 주소 0x0x0000 0004부터 코드 실행을 시작한다.

Cortex-M3 CPU는 리셋 벡터를 항상 ICode 버스로부터 페치하므로 부트 공간은 오직 코드 영역에만 존재할 수 있다. STM32 마이크로컨트롤러는 SRAM에서도 부팅할 수 있는 메커니즘을 제공한다.

SRAM 영역에서 부팅할 경우, NVIC 예외 테이블과 옵셋 레지스터를 설정하여 벡터테이블을 SRAM으로 재지정해야 한다.

벡터테이블은 Vector table offset register (`SCB_VTOR`) 레지스터에 0번지부터의 옵셋을 설정하는 것으로 옮길 수 있다. MSB인 29번째 비트가 1일 경우 SRAM으로 이동한다(동적으로 인터럽트 서비스 루틴을 등록하기 위해서는 벡터테이블을 SRAM으로 복사하는 것이 편리하다. 하지만 메모리 보호가 불가능하기 때문에 보안에 취약하다). 옵셋은 벡터 테이블의 서비스 갯수에 맞춰 정렬해야만 한다. 최소 128 words로 정렬해야 하며 이는 테이블 옵셋의 [8:0]비트가 항상 0임을 말한다.

### 실행 모드

Thread mode, Handler mode 두 종류의 모드가 있다. 핸들러 모드에서는 아무런 제약없이 시스템의 모든 자원을 이용 가능한 반면, 스레드 모드에서는 시스템 자원의 종류에 따라 사용이 제한된다(하지만, CONTROL 레지스터를 설정하여 제한된 자원에 접근할 수 있다). reset시 thread mode로 진입하며 CONTROL 레지스터의 privilieged 비트가 디폴트로 설정되어 있다. 즉, 제한없이 모든 자원에 접근가능한 상태다.

두 종류의 모드에 따라 사용하는 스택 역시 달라지는 데 이 역시 CONTROL 레지스터에서 설정 가능하다. 핸들러 모드에서는 MSP만 사용되고 핸들러 모드에서는 MSP 또는 PSP 중 선택 사용 가능하다. 디폴트는 MSP. 스레드 모드에서 PSP 스택을 사용하기 위해서는 `msr` 명령어로 CONTROL 레지스터의 ASPSEL 비트를 셋하면 된다. 주의할 것은 변경 후 바로 `isb` 명령어를 수행해 변경된 스택이 바로 적용될 수 있도록 해야한다.

CONTROL 레지스터는 privilige 모드에서만 변경 가능하다.

### 클럭 초기화

내부 RC 오실레이터(HSI)는 추가비용이 들지 않고 외부 오실레이터(HSE)에 비해 초기화 시간이 짧지만 캘러브레이션을 하더라도 HSE에 비해 정확도가 떨어진다.

시스템 리셋시 `RCC_CR` 레지스터의 초기값은 0x0000 xx83으로 HSI가 활성화되어 있다.

PLL 활성화 전에 클럭소스와 곱셈인수 설정을 완료해야 한다. 활성화 된 이후로 설정값은 변경될 수 없다. USB 인터페이스를 사용할 경우 PLL 출력은 48MHz 혹은 78MHz가 되어야 한다(USB 프리스케일러는 인수로 /1과 /1.5를 갖고 있음).

변경될 SYSCLK에 따라 다음과 같이 플래시 접근 시간을 맞춰주어야 한다:  
```
0 < SYSCLK ≤ 24 MHz = zero wait state  
24 MHz < SYSCLK ≤ 48 MHz = one wait state  
48 MHz < SYSCLK ≤ 72 MHz = two wait states  
```

아래 레지스터 설명은 초기화 순서대로 나열한다. 초기화는 아래 두 레지스터에서 설정된다:

* Clock control register (`RCC_CR`)
* Clock configuration register (`RCC_CFGR`)

1. 외부 클럭 설정
  - HSEON - 외부 클럭 활성화
  - HSERDY - 외부 클럭 안정화됐는지 확인 플래그
2. PLL 설정
  - PLLMUL (0111: PLL input clock x 9 = 72MHz, HSE가 8MHz일 때)
  - PLLSRC (1: HSE oscillator clock selected as PLL input clock)
  - PPRE1 (100: HCLK divided by 2 = 36MHz)
  - ADCPRE (10: PCLK2 divided by 6 = 12MHz)
  - PLLON
  - PLLRDY
  - SW (10: PLL selected as system clock)
  - SWS
3. Clock security system(CSS) 설정
  - CSSON 
4. 내부 클럭 종료
  - 플래시 프로그래밍 인터페이스에 직접 제공되므로 종료할 수 없음.
5. 주변기기 클럭 설정
  - AHB peripheral clock enable register (`RCC_AHBENR`)
	 - SDIO, FSMC, CRC, FLIT, SRAM, DMA
  - APB2 peripheral clock enable register (`RCC_APB2ENR`)
	 - Timer, IO, Alternative IO function, ADC, USART, SPI
  - APB1 peripheral clock enable register (`RCC_APB1ENR`)
	 - DAC, Power interface, Backup interface, CAN, USB, I2C, UART, SPI, WDT, Timer

***NOTE***

* LSEON(in `RCC_BDCR`) 비트를 설정하고 LSEBYP를 설정하면 외부 클럭 소스를 입력으로 받을 수 있다. `OSC32_OUT`핀은 Hi-Z상태여야만 한다.
* Independent watchdog (IWDG) 가 사용될 경우 LSI가 무조건 활성화 됨.

Control/status register (`RCC_CSR`) - 리셋 플래그와 LSI 설정

### GPIO 초기화

1. 해당 포트 클럭을 활성화한다(`RCC_APB2ENR`).
2. 포트가 지원하는 특수 기능(alternative function)을 사용할 경우, 해당 기능 클럭을 활성화한다.
3. 특수 기능 포트를 변경할 경우(AFIO) AFIO 클럭을 활성화한다.
4. 포트의 입/출력 모드와 옵션을 설정한다(`PORTx_CR`).

***NOTE***

```
x = port (A ~ G)
y = pin (0 ~ 15)
```

***`GPIOx_CRL`, `GPIOx_CRH`***

```
MODE | 설명
-----|-------------
 00  | 입력
 01  | 출력, 10MHz
 10  | 출력, 2MHz
 11  | 출력, 50MHz

CNFy | INPUT 모드일 때 | OUTPUT 모드일 때
-----|-----------------|-----------------
 00  | 아날로그 모드   | 일반 push-pull 출력
 01  | floating 입력   | 일반 open-drain 출력
 10  | 풀업/풀다운 입력| 대안 push-pull 출력
 11  | reserved        | 대안 open-drain 출력
```

## 인터럽트

인터럽트 컨트롤러(NVIC)가 Cortex-M3 core에 내장, 벡터가 지정되어 있으므로 외부 인터럽트 컨트롤러로 처리되는 기존의 ARM core에 비해 빠르다. 인터럽트 전/후에 {R0-R3, R12, LR, PC, PSR} 레지스터를 하드웨어적으로 스택에(msp 또는 psp 중 현재 사용중인) push/pop하므로 문맥전환에 드는 비용을 줄인다.

벡터 테이블의 0-15에 위치하는 예외는 Cortex-M3 internel exception으로 밴더 불문하고 동일 코어에서 일치한다. 16-255에 위치하는 예외는 밴더 특정 인터럽트다. thumb 코드임을 지시하기 위해 벡터 테이블의 분기 주소의 최하위 비트는 1이어야만 한다.

개별 예외에 대한 인에이블 제어는 `SCB_SHCSR`(0-15에 위치하는 예외), `NVIC_ISER`(나머지 예외) 레지스터에서 가능하다.

전역적인 인터럽트 인에이블 제어는 FAULTMASK와 PRIMASK 레지스터를 사용한다. FAULTMASK는 NMI를 제외한 모든 예외를 금지한다(NMI는 금지불가). NMI 핸들러를 제외한 예외 핸들러는 탈출할 때 자동적으로 FAULTMASK를 클리어한다. PRIMASK는 BASEPRI에 설정된 우선순위 이하의 모든 예외를 금지한다.

Reset과 Hard fault, NMI를 제외한 모든 예외는 우선순위를 가질 수 있다. 숫자가 낮을 수록 높은 우선순위를 가진다. 설정 가능한 모든 예외의 디폴트 값은 0이다.

시스템 핸들러(Memory management fault, Bus fault, Usage fault, SVCall, PendSV, SysTick) 우선순위는 `SCB_SHPR1~3` 레지스터에서 설정한다. 나머지 핸들러의 우선순위는 `NVIC_IPR0~20` 레지스터에서 설정한다. 예외 핸들러가 수행중이더라도 우선순위가 높은 예외가 발생하면 제어권이 높은 예외로 넘어간다. 우선순위가 같은 경우엔 선점하지 않고 pending 한다. 예외를 우선순위별로 그룹화할 수도 있다. 그룹 우선순위와 그룹 서브 우선순위가 있는데 동일 그룹내에서는 실행중인 핸들러보다 서브 우선순위가 높은 인터럽트가 발생하더라도 제어를 뺏기지 않는다.

인터럽트가 발생하면 문맥을 스택에 저장하는 동시에 벡터의 핸들러 시작주소를 패치한다. 스택처리가 끝나면 핸들러로 분기하며, 그와 동시에 LR레지스터에 `EXC_RETURN` 값을 쓴다. 이 값은 프로세서가 사용 중이던 스택 종류(MSP, PSP)와 모드(handler, thread) 값을 저장한다(`EXC_RETURN[3:0]` - MSP일 경우 1이나 9, PSP일 경우 0xd). 스택 프레임은 4바이트 단위 또는 8바이트 단위로 정렬할 수 있다(`SCB_CCR` 레지스터의 STKALIGN비트).

LR레지스터에 저장된 `EXC_RETURN`값은 핸들러 마지막 구문에서 PC로 로드되고, 프로세서는 `EXC_RETURN[31:4]` 값을 0xfffffff 으로 설정한다. PC에 이 값이 로드되면 프로세서는 예외처리가 끝내고 종료 절차를 밟는다(인터럽트 진입시 하드웨어적으로 스택에 저장한 문맥으로 다시 돌아간다).

`SCB_SCR`의 USERSETMPEND 비트가 설정되어 있다면 유저모드에서 `NVIC_STIR` 레지스터에 IRQ 번호를 써넣음으로써 해당 인터럽트를 pending 상태로 만들 수 있다.

엣지 검출 모드와 인터럽트 요청 활성 마스크를 설정하면 인터럽트 또는 이벤트가 발생한다. 이벤트의 경우 pending 비트는 셋되지 않는다. 인터럽트가 활성상태가 아니더라도 pending 비트는 셋된다. pending 비트에 1을 쓰면 리셋된다.

***"외부 인터럽트"***를 활성화하는 방법은 아래와 같다:

1. 외부 인터럽트 핀을 설정한다(`GPIO_CR`).
2. 외부 인터럽트 핀을 인터럽트 컨트롤러(EXTI)에 맵핑시킨다(`AFIO_EXTICR`).
3. 에지 검출 모드를 설정한다(`EXTI_RTSR`, `EXTI_FTSR`).
4. 인터럽트 마스크를 설정한다(`EXTI_IMR`).
5. 인터럽트를 활성화한다(`NVIC_ISER`).

### 하드웨어 외부 인터럽트

1. `EXTI_IMR` 레지스터를 설정한다(인터럽트 마스크 레지스터)
2. `EXTI_RTSR` 과 `EXTI_FTSR` 레지스터를 설정한다(에지 검출 모드 레지스터)
3. `AFIO_EXTICR` 레지스터를 설정한다(NVIC IRQ 채널과 EXTI 제어기 연결)

### 하드웨어 외부 이벤트

1. `EXTI_EMR` 레지스터를 설정한다(이벤트 마스크 레지스터)
2. `EXTI_RTSR` 과 `EXTI_FTSR` 레지스터를 설정한다(에지 검출 모드 레지스터)

### 소프트웨어 외부 인터럽트/이벤트

1. `EXTI_IMR` 또는 EMR 레지스터를 설정한다(인터럽트/이벤트 마스크 레지스터)
2. `EXTI_SWIER` 레지스터를 설정한다(소프트웨어 인터럽트 요청)

## 시스템 타이머SysTick Timer

24비트 타이머로 LOAD 레지스터 값부터 0까지 다운카운트한다. 프로세서 클럭을 사용하며 저전력 모드나 디버깅시 타이머는 정지한다. 1에서 0으로 다운카운팅 되는 순간 인터럽트가 걸린다. 카운터가 0에 도달했을 경우, `STK_CTRL` 레지스터의 COUNTFLAG가 셋된다. 읽으면 클리어된다. `STK_VAL` 레지스터 쓰기는 어떤 값이든 레지스터 값을 0으로 초기화 시키며 COUNTFLAG 비트를 클리어한다.

1. 타이머 리로드값을 설정한다(`STK_LOAD`)
2. 클럭소스를 선택한다(`STK_CTRL` 레지스터의 CLKSOURCE 비트)
3. Systick 인터럽트를 활성화한다(`STK_CTRL` 레지스터의 TICKINT 비트)
4. 카운터를 가동한다(`STK_CTRL`레지스터의 ENABLE 비트)
5. `STK_VAL` 레지스터로 현재 카운터 값을 확인하거나 `STK_CTRL` 레지스터의 COUNTFLAG 또는 인터럽트를 사용한다

## 타이머

타이머마다 4개의 채널을 갖고 있다. 각 채널은 입력과 출력으로 공통핀을 사용한다. 입출력은 CCMR1(채널 1, 2)과 CCMR2(채널 3, 4)레지스터의 CCS 비트를 통해 설정된다. 상태 레지스터는 SR, 인터럽트와 DMA 설정은 DIER 레지스터를 사용한다. 카운터 활성은 CR1 레지스터의 CEN 비트 셋으로 시작된다.

채널 입력은 `TIM_CCMR` 레지스터의 CCS[1:0] 통해 입력 소스가 선택된다. 입력 소스는 필터 다운 카운터(`TIM_CCMR` 레지스터의 ICF[3:0])를 거쳐 엣지검출(`TIM_CCER` 레지스터의 CCP)로 선택된다. 입력된 소스는 `TIM_CCMR1` 레지스터의 ICPS[1:0] 값만큼 프리스케일한다. 채널의 동작은 `TIM_CCER` 레지스터의 CCE 비트 셋으로 시작된다.

채널 출력은 `TIM_CCMR` 레지스터의 OCM[2:0] 통해 모드가 설정된다. active 레벨을 `TIM_CCER` 레지스터의 CCP 비트로 설정한다. 채널의 동작은 `TIM_CCER` 레지스터의 CCE 비트 셋으로 시작된다.
클럭은 내부와 외부에서 입력받을 수 있으며 하나의 타이머를 다른 타이머의 프리스케일러로 사용할 수 있다.

PWM 모드에서는 프리로드 레지스터가 반드시 활성화되어야 한다(CCMR1 레지스터의 OCPE 비트와 CR1 레지스터의 ARPE 비트). 프리로드 레지스터의 값은 업데이트 이벤트가 발생했을 시에만 섀도우 레지스터로 전송되기 때문에 카운터를 활성하기 전에 `TIM_EGR` 레지스터의 UG비트를 셋하므로써 레지스터들을 초기화한다.

## ADC

16 채널 12-bit ADC 는 PCLK2 클럭을 사용하며 14MHz를 넘어서는 안된다. 변환은 레귤러와 인젝션 두가지 그룹으로 나뉜다. 레귤러는 16개의 변환을 인젝션은 4개의 변환을 할 수 있다. 각 그룹의 변환 순서와 사용하는 총 갯수를 레지스터에 명시해야 한다. 변환도중 이 레지스터 값이 변화하면 진행중이던 변환은 리셋되고 다시 시작 펄스가 ADC에 전달된다. 레귤러와 인젝션은 서로 다른 데이터 레지스터 및 플래그 레지스터를 사용한다. Vref- 핀은 반드시 Vssa- 핀에 묶여야 한다. 타이머 캡처나 EXTI 라인을 통해 외부 트리거와 연동된다. 최대 1.17us 변환시간을 갖는다.

`ADC_CR2` 레지스터의 ADON 비트를 처음 셋하면 스타트 지연시간후 ADC가 활성화된다. 변환을 수행하기 위해서는 스타트 지연시간후 다시 한번 ADON 비트를 셋하면 된다. ADON 비트를 클리어하면 ADC는 동작하지 않으며 약간의 uA 전류만 소비한다.

`ADC_HTR`과 `ADC_LTR` 레지스터에 high threshold와 low threshold를 설정하여 변환 값이 해당 값보다 위나 아래로 떨어질 경우 `ADC_CR1` 레지스터의 AWDIE 비트를 셋하므로 인터럽트를 발생할 수 있다. 

스캔모드는 `ADC_SQR`(레귤러) 레지스터나 `ADC_JSQR`(인젝션) 레지스터에 설정된 모든 체널에 변환을 시작한다. CONT 비트가 셋되어 있으면 변환을 처음부터 반복한다. 결과값은 인젝션의 경우 `ADC_JDR` 레지스터에, 레귤러의 경우 DMA와 반드시 연동되어 SRAM에 결과가 저장되어야 한다.

레귤러 채널의 변환 값은 DR 레지스터를 덧쓰는 것을 방지하기 위해 DMA을 사용해야 한다.

인젝션 인터럽트는 레귤러 변환 중에 끼어들 수 있지만, 레귤러는 인젝션 변환 중에 끼어들지 못하고 인젝션 변환이 끝난 후에 변환을 수행한다. 인터럽트된 레귤러 변환은 리셋된 후 끼어든 인젝션 변환이 끝난 후 재시작한다.

전원인가시마다 캘러브레이션하기를 권장한다. 캘러브레이션은 ADC 전원이 인가된 후 최소한 2 ADC 클럭 사이클이 지난 후에 수행되어야 한다.

인젝션 그룹 체널의 변환 값은 사용자 지정 옵셋에 의해 감소할 수 있다. 

`ADC_SMPR` 레지스터의 SMP 비트를 설정하여 각 채널마다 다른 샘플 타임을 지정할 수 있다.

*** 내부 온도 센서 값 읽기 ***

1. ADC 프리스케일러 설정 (`RCC_CFGR` 레지스터의 ADCPRE)
2. ADC 클럭 인에이블
3. ADC 및 온도 센서 전원 인가 (`ADC_CR2` 레지스터의 ADON, TSVREFE)
4. 캘러브레이션 수행 (스타트지연 후에 `ARC_CR2` 레지스터의 CAL)
5. 변환 채널 설정 (`ADC_SQR`)
6. 샘플링 타임 지정(`ADC_SMPR`)
7. 변환 시작 (`ADC_CR2` 레지스터의 ADON)
8. 변환 완료 (`ADC_SR` 레지스터의 EOC 셋)

## 내장 플래시

16비트씩 프로그램될 수 있고, 쓰기와 삭제에는 내부 RC 오실레이터가(HSI) 반드시 활성화되어 있어야 한다. 플래시 메모리 삭제는 페이지 단위로 할 수 있고 전체 삭제도 가능하다. 전체 삭제는 information block에 영향을 끼치지 않는다.

ST사에서 제공하는 부트로더가 적재된 시스템 메모리에 관해서는 AN2606를 참고하라.

리셋 후 Flash program and erase controller (FPEC) 블럭은 보호된 상태로, `FLASH_CR` 레지스터에 접근할 수 없다. 보호해제는 `FLASH_KEYR` 레지스터에 KEY1과 KEY2 값을 연속으로(2 클럭 사이클) 입력으로 이루어진다. 잘못된 접근이 만들어지면 다음 리셋까지 보호상태를 해제할 수 없게 되며, 또한 버스 에러가 발생한다.

반대로 `FLASH_CR` 레지스터의 LOCK 비트를 1로 쓰면 보호상태로 만들 수 있다.

### 플래시 메모리 쓰기

쓰기는 16비트 단위로 이루어지며 크기가 다를 경우 버스 에러가 발생한다. 쓰기 와중에(BSY 비트가 1인 동안), 읽기/쓰기 명령이 수행되면 플래시 쓰기가 끝나기까지 명령은 수행을 중단한다. 쓰기를 시도하는 플래시 메모리의 위치가 삭제되어 있지 않은 경우, `FLASH_SR` 레지스터의 PGERR 비트가 셋되고 쓰기는 중단된다(단, 0을 쓸 때는 정상 동작한다). 혹은 `FLASH_WRPR` 레지스터에 의해 해당 영역이 보호된 경우 `FLASH_SR` 레지스터의 WRPRTERR 비트를 셋하고 중단한다.

1. `FLASH_CR` 레지스터의 LOCK 비트를 체크한다. 1일 경우 보호되어 있으므로 보호해제를 수행한다.
2. `FLASH_CR` 레지스터의 PG 비트를 셋한다.
3. 해당 주소에 16비트 쓰기를 수행한다.
4. `FLASH_SR` 레지스터의 BSY 비트를 체크한다. 1일 경우 쓰기 수행중이므로 기다린다.
5. 쓴 내용을 다시 읽어서 검증한다.

### 플래시 메모리 삭제

#### 페이지 삭제

1. `FLASH_CR` 레지스터의 LOCK 비트를 체크한다. 1일 경우 보호되어 있으므로 보호해제를 수행한다.
2. `FLASH_SR` 레지스터의 BSY 비트를 체크해, 다른 작업이 플래시 메모리에 수행 중인지 확인한다.
3. `FLASH_CR` 레지스터의 PER 비트를 셋한다.
4. 삭제할 페이지를 `FLASH_AR` 레지스터에 쓴다.
5. `FLASH_CR` 레지스터의 STRT 비트를 셋한다.
6. BSY 비트가 리셋될 때까지 기다린다.
7. 삭제된 페이지를 다시 읽어 검증한다.

#### 전체 삭제

1. `FLASH_CR` 레지스터의 LOCK 비트를 체크한다. 1일 경우 보호되어 있으므로 보호해제를 수행한다.
2. `FLASH_SR` 레지스터의 BSY 비트를 체크해, 다른 작업이 플래시 메모리에 수행 중인지 확인한다.
3. `FLASH_CR` 레지스터의 MER 비트를 셋한다.
4. `FLASH_CR` 레지스터의 STRT 비트를 셋한다.
5. BSY 비트가 리셋될 때까지 기다린다.
6. 다시 읽어 전체 삭제가 수행됐는지 검증한다.

### 옵션 바이트 프로그래밍

FPEC는 쓰기 전에 미리 읽기를 수행하여 해당 위치가 삭제되지 않았다면 `FLASH_SR` 레지스터의 PGERR 비트를 셋하고 수행을 중단한다. 정상 종료는 동일 레지스터의 EOP 비트로 나타낸다.

#### 옵션 바이트 쓰기

1. `FLASH_CR` 레지스터의 LOCK 비트를 체크한다. 1일 경우 보호되어 있으므로 보호해제를 수행한다.
2. `FLASH_SR` 레지스터의 BSY 비트를 체크해, 다른 작업이 플래시 메모리에 수행 중인지 확인한다.
3. `FLASH_OPTKEYR` 레지스터에 KEY1과 KEY2를 연속적으로 써서 옵션 바이트에 쓰기 권환을 얻는다(`FLASH_CR` 레지스터의 OPTWRE 비트가 자동으로 셋된다).
4. `FLASH_CR` 레지스터의 OPTPG 비트를 셋한다.
5. 정해진 위치에 16비트 쓰기를 수행한다.
6. BSY 비트가 리셋될 때까지 기다린다.
7. 다시 읽어 전체 삭제가 수행됐는지 검증한다.

When the Flash memory read protection option is changed from protected to unprotected, a Mass Erase of the main Flash memory is performed before reprogramming the read protection option. If the user wants to change an option other than the read protection option, then the mass erase is not performed. The erased state of the read protection option byte protects the Flash memory.

#### 옵션 바이트 삭제

1. `FLASH_CR` 레지스터의 LOCK 비트를 체크한다. 1일 경우 보호되어 있으므로 보호해제를 수행한다.
2. `FLASH_SR` 레지스터의 BSY 비트를 체크해, 다른 작업이 플래시 메모리에 수행 중인지 확인한다.
3. `FLASH_OPTKEYR` 레지스터에 KEY1과 KEY2를 연속적으로 써서 옵션 바이트에 쓰기 권환을 얻는다(`FLASH_CR` 레지스터의 OPTWRE 비트가 자동으로 셋된다).
4. `FLASH_CR` 레지스터의 OPTER 비트를 셋한다.
5. `FLASH_CR` 레지스터의 STRT 비트를 셋한다.
6. BSY 비트가 리셋될 때까지 기다린다.
7. 다시 읽어 검증한다.

### 플래시 메모리 보호

## USART protocol used in the STM32 boot loader

부트 모드가 시스템 메모리로 설정되면 부트로더는 `0x7F` 데이터 프레임을 수신하기 위해 `USARTx_RX` 핀을 스캔하기 시작한다. 데이터 프레임은 1개의 시작비트, 데이터, 짝수 패리트 비트, 그리고 1개의 스탑비트로 이루어진다.

데이터 프레임의 전송시간은 Systick 타이머로 측정된다. 타이머 값과 시스템 클럭을 참조해 보레이트를 계산하고, 시리얼 인터페이스를 초기화한다. 시리얼 인터페이스 초기화를 완료하고 호스트에서 명령을 수신할 준비가 되면 acknowledge byte (`0x79`) 를 전송한다.

***NOTE*** 

* 내부 초기화된 보레이트와 실제 호스트의 보레이트 편차는 2.5% 미만이어야 한다. 
* 보레이트는 최저 1200부터 최대 115200까지 수용될 수 있다.

모든 통신은 아래 방법을 통해 검증된다:

1. checksum - 전송된 데이터 바이트는 XOR된다. XOR된 바이트는 마지막 바이트로 전송된다. 모든 바이트를 (data + checksum) XOR하므로써 패킷의 마지막 XOR 값은 `0`이 되어야 한다.
2. 호스트는 커맨드 바이트와 함께 보수화된 커맨드 바이트를 전송한다.
3. UART - 짝수 패리티. 각 패킷은 성공적으로 수신되거나 (ACK) 무시된다 (NACK):
  * ACK = `0x79`
  * NACK = `0x1F`

### 명령어 목록

```
 Command           | Code | Command description
------------------------------------------------
 Get               | 0x00 | 버전과 현재 버전에서 제공하는 커맨드 리스트 얻기
 Get Version & Read
 Protection Status | 0x01 | 부트로더 버전과 플래시 메모리의 보호 상태 얻기
 Get ID            | 0x02 | 칩 ID 얻기
 Read Memory       | 0x11 | 지정된 주소로부터 최대 256바이트까지 읽기
 Go                | 0x21 | 내부 플래시 메모리나 SRAM의 위치로 분기
 Write Memory      | 0x31 | 지정된 주소로부터 최대 256바이트까지 쓰기
 Erase             | 0x43 | 플래시 메모리 지우기 (페이지 1개부터 전체)
 Extended Erase    | 0x44 | 두 바이트 어드레스 모드로 플래시 메모리 지우기 (페이지 1개부터 전체)
 Write Protect     | 0x63 | 특정 섹터에 대한 쓰기보호
 Write Unprotect   | 0x73 | 모든 플래시 메모리 섹터에 대한 쓰기보호 해제
 Readout Protect   | 0x82 | 읽기보호
 Readout Unprotect | 0x92 | 읽기보호 해제
```

***NOTE***

* 유효하지 않은 커맨드일 경우 부트로더는 NACK 바이트로 응답하고, 다시 명령수신 대기 상태가 된다. 
* 읽기보호 (RDP)된 경우 역시 NACK 바이트로 응답한다. 
* 하나의 디바이스에 Erase 명령과 Extended Erase 명령은 상호배타적으로 단 하나의 명령만 지원된다.

### 명령어 사용방법

#### Get command

부트로더의 버전과 제공되는 명령어의 리스트를 얻는다.

```
 CMD  | /CMD | CHKSUM
----------------------
 0x00 | 0xff | 
```

ACK, 패킷 사이즈(바이트), 버전, 명령어 리스트, ACK

#### Get Version & Read Protection Status command

부트로더 버전과 읽기보호 상태를 얻는다.

```
 CMD  | /CMD | CHKSUM
----------------------
 0x01 | 0xfe |
```

ACK, 버전, option1, option2, ACK

#### Get ID command

칩 ID를 얻는다.

```
 CMD  | /CMD | CHKSUM
----------------------
 0x02 | 0xfd | 
```

ACK, 패킷 사이즈(바이트), ID, ACK

#### Read Memory command

유효한 메모리 번지로부터 데이터를 얻는다.

```
 CMD  | /CMD | CHKSUM
----------------------
 0x11 | 0xee | 

ACK

 ADDR1 | ADDR2 | ADDR3 | ADDR4 | CHKSUM
----------------------------------------
 MSB   | ...   | ...   | LSB   |

ACK

 NUM                        | CHKSUM
-------------------------------------
| number of bytes to be read |

ACK, data
```

#### Go command

지정된 주소로 분기한다. 모든 과정이 정상적으로 진행되면 부트로더 펌웨어는 다음을 수행한다:

  - 부트로더가 사용한 레지스터 값들을 초기 디폴트 리셋 값으로 되돌린다.
  - 사용자 메인 스택 포인터를 초기화한다.
  - 지정된 주소 + 4로 분기한다. 만약 주소 `0x0800 0000`가 지정되었다면, 부트로더는 주소 `0x0800 0004`로 분기한다.

***NOTE***

  프로그램을 RAM에 로드하고 분기할 경우 부트로더가 사용하는 RAM의 앞부분과 겹치지 않도록 프로그램은 RAM 옵셋을 고려해야만 한다. `AN2606`을 참고하라.

```
 CMD  | /CMD | CHKSUM
----------------------
 0x21 | 0xde | 

ACK

 ADDR1 | ADDR2 | ADDR3 | ADDR4 | CHKSUM
----------------------------------------
 MSB   | ...   | ...   | LSB   |

ACK
```

#### Write Memory command

유효 메모리 주소에 데이터를 쓴다. 모든 과정이 정상적으로 진행되면 다음을 수행한다:

  - 수신할 데이터 사이즈를 바이트 크기로 전송받는다(N + 1은 4의 배수여야만 함).
  - 데이터와 체크섬을 전송받는다.
  - 전송받은 주소에 전송받은 데이터를 쓴다.
  - 성공시 ACK, 실패시 NACK 전송한다.

최대 블럭 크기는 256바이트이다(수신할 데이터 사이즈가 1 바이트이므로).

메모리 쓰기 명령이 옵션 바이트 영역에 적용될 경우 모든 옵션 값들이 삭제되고 새 값을 쓴 이후에는 시스템에 적용하기 위해 리셋한다.

```
 CMD  | /CMD | CHKSUM
----------------------
 0x31 | 0xce | 

ACK

 ADDR1 | ADDR2 | ADDR3 | ADDR4 | CHKSUM
----------------------------------------
 MSB   | ...   | ...   | LSB   |

ACK

 SIZE  | CHKSUM
----------------------
 number of bytes to be written 

ACK
```

#### Erase Memory command


1. 지워질 페이지 갯수를 입력받는다(1 byte). N = 255일 경우 전체 삭제한다. 0 <= N <= 254일 때, N+1개의 페이지가 삭제된다.
2. 부트로더는 N+1바이트를 입력받는다. 각 바이트는 페이지 번호를 나타낸다.

플래시 메모리를 페이지 단위로 삭제한다.

```
 CMD  | /CMD | CHKSUM
----------------------
 0x43 | 0xbc | 

ACK

 NUMBER                           | PAGE CODE | CHKSUM
-------------------------------------------------------
 number of pages to be erased - 1 | N + 1     | 

ACK
```

#### Extended Erase Memory command

1. 지워질 페이지 갯수를 입력받는다(2 byte).
  - `N = 0xffff`일 때 전체 삭제
  - `N = 0xfffe`일 때 뱅크1 전체 삭제
  - `N = 0xfffd`일 때 뱅크2 전체 삭제
  - `N = 0xfff0 ~ 0xfffc`는 예약됨
  - 0 <= N <= max일 때 N + 1개의 페이지가 삭제됨
2. 부트로더는 다음과 같은 데이터를 전송받는다:
  * 스페셜 삭제일 경우 체크섬은:
	 - `0xffff` - `0x00`
	 - `0xfffe` - `0x01`
	 - `0xfffd` - `0x02`
  * N+1 삭제일 경우 (2 \* (N + 1)) 바이트를 전송받는다. 각 2바이트는 페이지 번호를 나타낸다. 그리고 체크섬.

플래시 메모리를 페이지 단위로 삭제한다.

```
 CMD  | /CMD | CHKSUM
----------------------
 0x44 | 0xbb | 

ACK

 NUMBER_H | NUMBER_L              | PAGE CODE_H | PAGE CODE_L | CHKSUM
-----------------------------------------------------------------------
 number of pages to be erased - 1 | N + 1                     | 

ACK
```

#### Write Protect command

#### Write Unprotect command

#### Readout Protect command

#### Readout Unprotect command

## 참고자료

* [Cortex™-M3 Technical Reference Manual](http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337i/index.html)  
* [Datasheet](http://www.st.com/st-web-ui/static/active/en/resource/technical/document/datasheet/CD00191185.pdf)  
* [Reference Manual](http://www.st.com/st-web-ui/static/active/en/resource/technical/document/reference_manual/CD00171190.pdf)  
* [Programming Manual](http://www.st.com/st-web-ui/static/active/en/resource/technical/document/programming_manual/CD00228163.pdf)  
* [Flash Memory](http://www.st.com/st-web-ui/static/active/en/resource/technical/document/programming_manual/CD00283419.pdf)  
* [USART bootloader protocol](http://www.st.com/web/en/resource/technical/document/application_note/CD00264342.pdf)  
* [stm32flash](https://code.google.com/p/stm32flash/)

# Building Cross Compile Toolchain

## Prepare

```
export PREFIX = /usr/local/arm
export TARGET = arm-none-eabi
```

## binutil

```
$ ../configure --target=$TARGET --prefix=$PREFIX --enable-interwork --disable-nls
$ make
$ make install
```

## gcc

```
mpc
mpfr
gmp

$ ../configure --target=$TARGET --prefix=$PREFIX \
--enable-interwork --disable-nls --enable-languages="c,c++" \
--without-headers --with-newlib \
--with-headers=$WORKING_DIR/newlib/newlib/libc/include
$ make all-gcc
$ make install-gcc
```

## newlib

```
$ ../configure --target=$TARGET --prefix=$PREFIX --enable-interwork
$ make
$ make install
```

## gcc final

```
cp -R newlib/newlib/libc/include $PREFIX/arm-none-eabi/sys-include

$ make
$ make install
```
