/** @file uaart.c */

#include "arch/mach/uart.h"
#include "arch/mach/exti.h"
#include "arch/mach/clock.h"
#include "arch/mach/board/pinmap.h"
#include "log.h"

#include <stdbool.h>
#include <errno.h>
#include <stdlib.h>

enum {
	RE	= 2, /* Receiver enable */
	TE	= 3, /* Transmitter enable */
	RXNEIE	= 5, /* RXNE interrupt enable */
	RXNE	= 5,
	TXE	= 7,
#ifdef stm32f3
	UE	= 0, /* USART enable */
#else
	UE	= 13,
#endif
};

struct _regs {
	/*unsigned int sr;*/
	/*unsigned int dr;*/
	unsigned int brr;
	unsigned int cr1;
	unsigned int cr2;
	unsigned int cr3;
	unsigned int gtpr;
};

static unsigned int brr2reg(unsigned int baudrate, unsigned int clk)
{
	unsigned int fraction, mantissa;

	/* 25 * 4 = 100; not to lose the result below the decimal point */
	fraction = (clk * 25) / (baudrate * 4);
	mantissa = fraction / 100; /* to get the actual integer part */
	fraction = fraction - (mantissa * 100); /* to get the fraction part */
	fraction = ((fraction << 4/* sampling */) + 50/* round up */) / 100;
	baudrate = (mantissa << 4) | (fraction & 0xf);

	return baudrate;
}

static inline int ch2vec(const int channel)
{
	int nvec = -1;

	if (channel < 3)
		nvec = 53 + channel;
	else if (channel < 5)
		nvec = 68 + channel - 3;
	else if (channel == 5)
		nvec = 87;
	else
		nvec = 98 + channel - 6;

	return nvec;
}

static inline reg_t *ch2reg(const int channel)
{
	reg_t *reg = NULL;

	switch (channel) {
	case 0: reg = (reg_t *)USART1;
		break;
	case 1: reg = (reg_t *)USART2;
		break;
	case 2: reg = (reg_t *)USART3;
		break;
#ifdef UART4
	case 3: reg = (reg_t *)UART4;
		break;
#endif
#ifdef UART5
	case 4: reg = (reg_t *)UART5;
		break;
#endif
#ifdef USART6
	case 5: reg = (reg_t *)USART6;
		break;
#endif
	case 6:
	case 7:
		debug("UART7,8 are not supported");
		break;
	default:
		break;
	}

	return reg;
}

static inline int uart_open(const int channel, struct _regs arg)
{
	reg_t *reg;

	if (!(reg = ch2reg(channel)))
		return -EINVAL;

	if ((unsigned int)reg & 0x10000) { /* if USART1 or USART6 */
#if defined(stm32f1) || defined(stm32f3)
		__turn_apb2_clock(14, true);
		__reset_apb2_device(14);
#elif defined(stm32f4)
		__turn_apb2_clock(4 + (channel >> 2), true);
		__reset_apb2_device(4 + (channel >> 2));
#else
#error undefined machine
#endif
		arg.brr = brr2reg(arg.brr, get_pclk2());
	} else {
		__turn_apb1_clock(channel + 16, true);
		__reset_apb1_device(channel + 16);

		arg.brr = brr2reg(arg.brr, get_pclk1());
	}

#ifdef stm32f3
	reg[0] = arg.cr1;
	reg[1] = arg.cr2;
	reg[2] = arg.cr3;
	reg[3] = arg.brr;
	reg[4] = arg.gtpr;
#elif defined(stm32f1) || defined(stm32f4)
	reg[2] = arg.brr;
	reg[3] = arg.cr1;
	reg[4] = arg.cr2;
	reg[5] = arg.cr3;
	reg[6] = arg.gtpr;
#else
#error undefined machine
#endif

	nvic_enable(ch2vec(channel), true);

	return ch2vec(channel);
}

static inline void uart_close(const int channel)
{
	reg_t *reg;

	if (!(reg = ch2reg(channel)))
		return;

	/* check if still in transmission. */
#ifdef stm32f3
	while (!gbi(reg[7], TXE));
#elif defined(stm32f1) || defined(stm32f4)
	while (!gbi(reg[0], TXE)); /* wait until TXE bit set */
#else
#error undefined machine
#endif

	if ((unsigned int)reg & 0x10000) { /* if USART1 or USART6 */
#if defined(stm32f1) || defined(stm32f3)
		__turn_apb2_clock(14, false);
#elif defined(stm32f4)
		__turn_apb2_clock(4 + (channel >> 3), false);
#else
#error undefined machine
#endif
	} else {
		__turn_apb1_clock(channel + 16, false);
	}

	nvic_enable(ch2vec(channel), false);
	/* TODO: gpio_fini() and unlink_exti_to_nvic() */
}

static inline int uart_putc(const int channel, const int c)
{
	reg_t *reg;

	if (!(reg = ch2reg(channel)))
		return 0;

	/* FIXME: Disable interrupt between checking and writing
	 * to make sure nothing interrupts in the mean time. */
#ifdef stm32f3
	if (!gbi(reg[7], TXE))
		return 0;
#else
	if (!gbi(reg[0], TXE))
		return 0;
#endif

#ifdef stm32f3
	reg[10] = (unsigned int)c;
#else
	reg[1] = (unsigned int)c;
#endif

	return 1;
}

static inline int set_uart_port(const int channel, struct uart *conf)
{
	/* TODO: in case of remapping, check pinout. */
	if (conf->rx) {
		if (!conf->npin_rx) {
			switch (channel) {
			case 0:
#ifdef PIN_UART1_RX
				conf->npin_rx = PIN_UART1_RX;
#else
				goto errout;
#endif
				break;
			case 1:
#ifdef PIN_UART2_RX
				conf->npin_rx = PIN_UART2_RX;
#else
				goto errout;
#endif
				break;
			case 2:
#ifdef PIN_UART3_RX
				conf->npin_rx = PIN_UART3_RX;
#else
				goto errout;
#endif
				break;
			case 5:
#ifdef PIN_UART6_RX
				conf->npin_rx = PIN_UART6_RX;
#else
				goto errout;
#endif
				break;
			default:
				goto errout;
				break;
			}
		}

		if (channel < 5)
			gpio_init(conf->npin_rx, gpio_altfunc(7));
		else /* USART6 */
			gpio_init(conf->npin_rx, gpio_altfunc(8));

		/* TODO: FOR TEST, use rx pin as wake-up source */
		/* FIXME: register handler */
		exti_enable(conf->npin_rx, true);
	}

	if (conf->tx) {
		if (!conf->npin_tx) {
			switch (channel) {
			case 0:
#ifdef PIN_UART1_TX
				conf->npin_tx = PIN_UART1_TX;
#else
				goto errout;
#endif
				break;
			case 1:
#ifdef PIN_UART2_TX
				conf->npin_tx = PIN_UART2_TX;
#else
				goto errout;
#endif
				break;
			case 2:
#ifdef PIN_UART3_TX
				conf->npin_tx = PIN_UART3_TX;
#else
				goto errout;
#endif
				break;
			case 5:
#ifdef PIN_UART6_TX
				conf->npin_tx = PIN_UART6_TX;
#else
				goto errout;
#endif
				break;
			default:
				goto errout;
				break;
			}
		}

		if (channel < 5)
			gpio_init(conf->npin_tx, gpio_altfunc(7) | GPIO_SPD_FASTEST);
		else
			gpio_init(conf->npin_tx, gpio_altfunc(8) | GPIO_SPD_FASTEST);
	}

	if (conf->flow) {
		if (!conf->npin_rts) {
		}
		if (!conf->npin_cts) {
		}
	}

	return 0;
errout:
	debug("PIN_UARTx_[R|T]X is not defined");
	return -ERANGE;
}

/* TODO: support flow control and parity */
int __uart_open(const int channel, struct uart conf)
{
	unsigned int cr1, cr2, cr3, gtpr;

	cr1 = cr2 = cr3 = gtpr = 0;

	if (set_uart_port(channel, &conf))
		return -ERANGE;

	if (conf.rx)
		cr1 |= (1UL << RE) | (1UL << RXNEIE);
	if (conf.tx)
		cr1 |= 1UL << TE;

	cr1 |= 1UL << UE;

	return uart_open(channel, (struct _regs) {
			.brr = conf.baudrate,
			.cr1 = cr1,
			.cr2 = cr2,
			.cr3 = cr3,
			.gtpr = gtpr });
}

void __uart_close(const int channel)
{
	uart_close(channel);
}

int __uart_putc(const int channel, const int c)
{
	return uart_putc(channel, c);
}

bool __uart_has_rx(const int channel)
{
	reg_t *reg;

	if (!(reg = ch2reg(channel)))
		return false;

#ifdef stm32f3
	if (reg[7] & (1UL << RXNE))
		return true;
#else
	if (reg[0] & (1UL << RXNE))
		return true;
#endif

	return false;
}

bool __uart_has_tx(const int channel)
{
	reg_t *reg;

	if (!(reg = ch2reg(channel)))
		return false;

#ifdef stm32f3
	if (reg[7] & (1UL << TXE))
		return true;
#else
	if (reg[0] & (1UL << TXE))
		return true;
#endif

	return false;
}

int __uart_getc(const int channel)
{
	reg_t *reg;

	if (!(reg = ch2reg(channel)))
		return false;

#ifdef stm32f3
	return reg[9];
#else
	return reg[1];
#endif
}

void __uart_tx_irq_reset(const int channel)
{
	reg_t *reg;

	if (!(reg = ch2reg(channel)))
		return;

	/* TXE interrupt disable */
#ifdef stm32f3
	reg[0] &= ~(1UL << TXE); /* TXEIE */
#else
	reg[3] &= ~(1UL << TXE); /* TXEIE */
#endif
}

void __uart_tx_irq_raise(const int channel)
{
	reg_t *reg;

	if (!(reg = ch2reg(channel)))
		return;

	/* TXE interrupt enable */
#ifdef stm32f3
	reg[0] |= 1UL << TXE; /* TXEIE */
#else
	reg[3] |= 1UL << TXE; /* TXEIE */
#endif
}

void __uart_flush(const int channel)
{
	reg_t *reg;

	if (!(reg = ch2reg(channel)))
		return;

	/* wait until transmission complete */
#ifdef stm32f3
	while (!gbi(reg[7], 6));
#else
	while (!gbi(reg[0], 6));
#endif
}

unsigned int __uart_get_baudrate(const int channel)
{
	(void)channel;
	return 0;
}

int __uart_set_baudrate(const int channel, unsigned int baudrate)
{
	reg_t *reg;

	if (!(reg = ch2reg(channel)))
		return 0;

	if (!channel) /* USART1 */
		baudrate = brr2reg(baudrate, get_pclk2());
	else
		baudrate = brr2reg(baudrate, get_pclk1());

#ifdef stm32f3
	reg[3] = baudrate;
#else
	reg[2] = baudrate;
#endif

	return 0;
}
